from google.adk.agents import LlmAgent, InvocationContext
from google.adk.tools import VertexAiSearchTool
import asyncio
import os
import uuid
from datetime import datetime

# Configuration Vertex AI Search
DATA_STORE_ID = "projects/airy-shuttle-468014-n1/locations/eu/collections/default_collection/dataStores/tachrone_1754589027742"

# Lecture des instructions depuis le fichier txt
def lire_instructions():
    """Lit les instructions depuis le fichier instructions.txt"""
    chemin_instructions = os.path.join(os.path.dirname(__file__), "instructions.txt")
    
    try:
        with open(chemin_instructions, 'r', encoding='utf-8') as fichier:
            return fichier.read()
    except FileNotFoundError:
        print(f"‚ö†Ô∏è  Le fichier {chemin_instructions} n'a pas √©t√© trouv√©.")
        # Instructions par d√©faut si le fichier n'existe pas
        return """
Vous √™tes un Expert Guide Acqu√©reur sp√©cialis√© dans l'immobilier au Maroc.

Votre r√¥le :
- Accompagner les acqu√©reurs dans toutes les √©tapes de leur projet immobilier
- Fournir des conseils personnalis√©s et pr√©cis
- Utiliser les outils √† disposition pour calculer, v√©rifier et analyser
- Rechercher dans la base de connaissances pour des informations d√©taill√©es

Vous √™tes comp√©tent dans :
- L'analyse des √©tapes d'acquisition
- La v√©rification des promoteurs FNPI
- Le calcul de capacit√© d'emprunt
- L'analyse des compromis de vente
- Les checklists de livraison
- Le calcul de la fiscalit√© immobili√®re

R√©pondez toujours de mani√®re professionnelle, pr√©cise et adapt√©e au contexte marocain.
"""
    except Exception as e:
        print(f"Erreur lors de la lecture du fichier: {e}")
        return "Vous √™tes un expert en immobilier au Maroc."

# Outils pour l'agent
def analyser_etape_actuelle(description_situation: str) -> str:
    """
    Analyse la situation de l'utilisateur et d√©termine son √©tape dans le processus d'acquisition
    
    Args:
        description_situation (str): Description de la situation actuelle de l'utilisateur
    
    Returns:
        str: Analyse de l'√©tape actuelle et recommandations
    """
    return f"""
### üîç Analyse de votre situation
**Description fournie :** {description_situation}

### üìç √âtape d√©termin√©e
Bas√© sur votre description, vous semblez √™tre √† l'√©tape [√âTAPE √Ä D√âTERMINER]

### ‚úÖ Actions recommand√©es pour cette √©tape
[ACTIONS SP√âCIFIQUES SELON L'√âTAPE]

### ‚ö†Ô∏è Points de vigilance
[POINTS CRITIQUES √Ä V√âRIFIER]

### ‚û°Ô∏è Prochaines √©tapes
[√âTAPES SUIVANTES √Ä SUIVRE]
"""

def verifier_promoteur_fnpi(nom_promoteur: str) -> str:
    """
    V√©rifie si un promoteur est membre de la FNPI
    
    Args:
        nom_promoteur (str): Nom du promoteur √† v√©rifier
    
    Returns:
        str: R√©sultat de la v√©rification
    """
    return f"""
### üè¢ V√©rification Promoteur FNPI
**Promoteur recherch√© :** {nom_promoteur}

### üéØ Statut FNPI
[STATUT √Ä D√âTERMINER - MEMBRE OU NON]

### üìã Informations compl√©mentaires
- **Label ILTIZAM :** [OUI/NON]
- **Historique :** [INFORMATIONS DISPONIBLES]
- **R√©putation :** [√âVALUATION]

### üí° Recommandations
[CONSEILS SELON LE STATUT]
"""

def calculer_capacite_emprunt(revenus_mensuels: float, charges_mensuelles: float, apport_initial: float) -> str:
    """
    Calcule la capacit√© d'emprunt d'un acqu√©reur
    
    Args:
        revenus_mensuels (float): Revenus mensuels nets
        charges_mensuelles (float): Charges mensuelles actuelles
        apport_initial (float): Apport initial disponible
    
    Returns:
        str: Calcul d√©taill√© de la capacit√© d'emprunt
    """
    # Calcul simplifi√© (√† adapter selon les r√®gles marocaines)
    revenus_disponibles = revenus_mensuels - charges_mensuels
    capacite_mensuelle = revenus_disponibles * 0.33  # 33% du revenu disponible
    capacite_totale = capacite_mensuelle * 25 * 12  # 25 ans √† 12 mois
    
    return f"""
### üí∞ Calcul de Capacit√© d'Emprunt
**Revenus mensuels :** {revenus_mensuels:,.2f} DH
**Charges mensuelles :** {charges_mensuelles:,.2f} DH
**Apport initial :** {apport_initial:,.2f} DH

### üìä Capacit√© calcul√©e
- **Revenus disponibles :** {revenus_disponibles:,.2f} DH
- **Mensualit√© maximale :** {capacite_mensuelle:,.2f} DH
- **Capacit√© totale :** {capacite_totale:,.2f} DH
- **Capacit√© avec apport :** {capacite_totale + apport_initial:,.2f} DH

### üí° Recommandations
- **Budget recommand√© :** {capacite_totale * 0.8:,.2f} DH (80% de la capacit√©)
- **Mensualit√© confortable :** {capacite_mensuelle * 0.8:,.2f} DH
"""

def analyser_compromis_vente(texte_compromis: str) -> str:
    """
    Analyse un compromis de vente
    
    Args:
        texte_compromis (str): Texte du compromis √† analyser
    
    Returns:
        str: Analyse d√©taill√©e du compromis
    """
    return f"""
### üìÑ Analyse du Compromis de Vente
**Texte analys√© :** {texte_compromis[:200]}...

### üîç Points Critiques √† V√©rifier
1. **Prix et modalit√©s de paiement**
2. **D√©lais et conditions suspensives**
3. **Garanties et responsabilit√©s**
4. **Clauses de r√©solution**

### üí° Recommandations
[CONSEILS SP√âCIFIQUES SELON L'ANALYSE]

### ‚ö†Ô∏è Points de vigilance
[√âL√âMENTS √Ä SURVEILLER]
"""

def checklist_visite_livraison() -> str:
    """
    G√©n√®re une checklist compl√®te pour la visite de livraison
    
    Returns:
        str: Checklist d√©taill√©e
    """
    return """
### üìã Checklist Visite de Livraison

#### 1. üè† V√©rifications G√©n√©rales
- [ ] Conformit√© aux plans
- [ ] Finitions g√©n√©rales
- [ ] Propret√© du chantier

#### 2. ‚ö° √âl√©ments Techniques
- [ ] √âlectricit√© (prises, √©clairage)
- [ ] Plomberie (robinets, √©vacuations)
- [ ] Chauffage/Climatisation
- [ ] Isolation (thermique, phonique)

#### 3. üé® Finitions
- [ ] Peintures et rev√™tements
- [ ] Menuiseries (portes, fen√™tres)
- [ ] Sols et plafonds
- [ ] √âquipements int√©gr√©s

#### 4. üõ°Ô∏è S√©curit√©
- [ ] D√©tecteurs de fum√©e
- [ ] √âclairage de s√©curit√©
- [ ] Acc√®s et √©vacuation

#### 5. üìÑ Documents √† v√©rifier
- [ ] Attestation de conformit√©
- [ ] Garanties constructeur
- [ ] Plans de r√©ception
"""

def calculer_fiscalite(prix_achat: float, type_bien: str, residence_principale: bool = True) -> str:
    """
    Calcule les obligations fiscales pour un achat immobilier
    
    Args:
        prix_achat (float): Prix d'achat du bien
        type_bien (str): Type de bien (appartement, maison, terrain)
        residence_principale (bool): Si c'est la r√©sidence principale
    
    Returns:
        str: Calcul d√©taill√© de la fiscalit√©
    """
    # Calculs simplifi√©s (√† adapter selon la fiscalit√© marocaine actuelle)
    droits_enregistrement = prix_achat * 0.025  # 2.5%
    taxe_commune = prix_achat * 0.01  # 1%
    frais_notaire = prix_achat * 0.015  # 1.5%
    
    total_fiscalite = droits_enregistrement + taxe_commune + frais_notaire
    
    return f"""
### üèõÔ∏è Calcul Fiscalit√© Immobili√®re
**Prix d'achat :** {prix_achat:,.2f} DH
**Type de bien :** {type_bien}
**R√©sidence principale :** {'Oui' if residence_principale else 'Non'}

### üí∞ D√©tail des taxes
- **Droits d'enregistrement :** {droits_enregistrement:,.2f} DH (2.5%)
- **Taxe communale :** {taxe_commune:,.2f} DH (1%)
- **Frais de notaire :** {frais_notaire:,.2f} DH (1.5%)

### üìä Total fiscalit√©
**Montant total :** {total_fiscalite:,.2f} DH
**Pourcentage :** {(total_fiscalite/prix_achat)*100:.1f}%

### üí° Recommandations
- Pr√©voyez ces montants en plus du prix d'achat
- V√©rifiez les exon√©rations possibles
- Consultez un expert-comptable pour optimiser
"""

async def create_invocation_context(agent):
    """Cr√©e un InvocationContext valide pour l'agent"""
    
    try:
        # Essayons d'importer les classes n√©cessaires
        try:
            from google.adk.core import Session, SessionService
        except ImportError:
            try:
                from google.adk.agents import Session, SessionService
            except ImportError:
                try:
                    from google.adk import Session, SessionService
                except ImportError:
                    # Cr√©ons des classes mock
                    class MockSession:
                        def __init__(self):
                            self.id = str(uuid.uuid4())
                            self.created_at = datetime.now()
                    
                    class MockSessionService:
                        def __init__(self):
                            self.name = "expert_guide_session_service"
                    
                    Session = MockSession
                    SessionService = MockSessionService
        
        # Cr√©ons les objets requis
        session_service = SessionService()
        session = Session()
        invocation_id = str(uuid.uuid4())
        
        # Cr√©ons le contexte
        context = InvocationContext(
            session_service=session_service,
            invocation_id=invocation_id,
            agent=agent,
            session=session
        )
        
        return context
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la cr√©ation du contexte: {e}")
        # Tentative avec model_construct
        try:
            context = InvocationContext.model_construct(
                session_service={"name": "expert_guide_service"},
                invocation_id=str(uuid.uuid4()),
                agent=agent,
                session={"id": str(uuid.uuid4()), "created_at": datetime.now()}
            )
            return context
        except Exception as e2:
            print(f"‚ùå model_construct √©chou√©: {e2}")
            raise

# Cr√©ation de l'agent avec Vertex AI Search Tool
def create_guide_acquereur_agent():
    """Cr√©e l'agent Expert Guide Acqu√©reur avec Vertex AI Search"""
    
    # Lecture des instructions
    instructions = lire_instructions()
    
    # Instructions enrichies incluant les capacit√©s des outils
    instructions_completes = f"""
{instructions}

OUTILS DISPONIBLES:
Vous avez acc√®s aux outils de calcul suivants via des appels de fonction :

1. analyser_etape_actuelle(description) - Analyse l'√©tape d'acquisition
2. calculer_capacite_emprunt(revenus, charges, apport) - Calcule la capacit√© financi√®re  
3. calculer_fiscalite(prix, type_bien, residence_principale) - Calcule taxes et frais
4. verifier_promoteur_fnpi(nom) - V√©rifie un promoteur FNPI
5. checklist_visite_livraison() - G√©n√®re une checklist de livraison
6. analyser_compromis_vente(texte) - Analyse un compromis

IMPORTANT: Quand un utilisateur demande des calculs ou analyses, proposez d'utiliser ces outils et demandez les informations n√©cessaires.

Vous pouvez √©galement rechercher dans la base de connaissances Vertex AI pour des informations d√©taill√©es sur l'immobilier au Maroc.
"""
    
    # Configuration du Vertex AI Search Tool
    search_tool = VertexAiSearchTool(data_store_id=DATA_STORE_ID)
    
    # Cr√©ation de l'agent avec SEULEMENT l'outil de recherche
    agent = LlmAgent(
        name="Expert_Guide_Acquereur",
        model="gemini-2.0-flash",
        instruction=instructions_completes,
        tools=[search_tool]  # SEULEMENT Vertex AI Search
    )
    
    return agent

async def chat_with_agent_and_tools(agent, question: str, context):
    """Fonction helper pour discuter avec l'agent et g√©rer les outils externes"""
    
    print(f"ü§ñ **Question:** {question}")
    print("üì§ Envoi √† l'Expert Guide Acqu√©reur...")
    print("-" * 60)
    
    try:
        response_parts = []
        event_count = 0
        
        async for event in agent.run_async(context):
            event_count += 1
            
            # Extraction du contenu de l'√©v√©nement
            if hasattr(event, 'content') and event.content:
                content = str(event.content)
                response_parts.append(content)
                print(content, end='')
            elif hasattr(event, 'message') and event.message:
                content = str(event.message)
                response_parts.append(content)
                print(content, end='')
            elif hasattr(event, 'text') and event.text:
                content = str(event.text)
                response_parts.append(content)
                print(content, end='')
            
            # Limitons les √©v√©nements
            if event_count >= 50:
                break
        
        print("\n" + "-" * 60)
        
        if response_parts:
            full_response = "".join(response_parts)
            
            # Post-traitement : D√©tection si des outils doivent √™tre utilis√©s
            await process_tool_requests(full_response, question)
            
            print(f"‚úÖ R√©ponse re√ßue ({event_count} √©v√©nements)")
            return full_response
        else:
            print(f"‚ö†Ô∏è Aucune r√©ponse textuelle extraite ({event_count} √©v√©nements)")
            return None
            
    except Exception as e:
        print(f"‚ùå Erreur lors de l'ex√©cution: {e}")
        import traceback
        traceback.print_exc()
        return None

async def process_tool_requests(response: str, original_question: str):
    """Traite les demandes d'utilisation d'outils bas√©es sur la r√©ponse"""
    
    # D√©tection des besoins de calcul dans la question originale
    question_lower = original_question.lower()
    
    if any(word in question_lower for word in ['capacit√©', 'emprunt', 'gagne', 'revenus', 'charges']):
        print("\nüßÆ **OUTIL D√âTECT√â**: Calcul de capacit√© d'emprunt")
        if 'dh' in question_lower or any(char.isdigit() for char in original_question):
            # Tentative d'extraction des chiffres (exemple simplifi√©)
            import re
            numbers = re.findall(r'\d+', original_question)
            if len(numbers) >= 2:
                try:
                    revenus = float(numbers[0]) if len(numbers) > 0 else 15000
                    charges = float(numbers[1]) if len(numbers) > 1 else 3000
                    apport = float(numbers[2]) if len(numbers) > 2 else 200000
                    
                    print("üí∞ Calcul automatique avec les valeurs d√©tect√©es:")
                    resultat = calculer_capacite_emprunt(revenus, charges, apport)
                    print(resultat)
                except:
                    print("üí° Pour un calcul pr√©cis, veuillez fournir: revenus mensuels, charges, apport")
    
    elif any(word in question_lower for word in ['frais', 'taxes', 'fiscalit√©', 'co√ªt']):
        print("\nüèõÔ∏è **OUTIL D√âTECT√â**: Calcul de fiscalit√©")
        numbers = re.findall(r'\d+', original_question)
        if numbers:
            try:
                prix = float(numbers[0])
                if prix > 10000:  # Si c'est un prix r√©aliste
                    print("üí∞ Calcul automatique de la fiscalit√©:")
                    resultat = calculer_fiscalite(prix, "appartement", True)
                    print(resultat)
            except:
                print("üí° Pour un calcul pr√©cis, pr√©cisez le prix d'achat")
    
    elif any(word in question_lower for word in ['checklist', 'livraison', 'r√©ception', 'visite']):
        print("\nüìã **OUTIL D√âTECT√â**: Checklist de livraison")
        print("üìã G√©n√©ration automatique de la checklist:")
        resultat = checklist_visite_livraison()
        print(resultat)
    
    elif any(word in question_lower for word in ['promoteur', 'fnpi', 'v√©rifier', 'fiable']):
        print("\nüè¢ **OUTIL D√âTECT√â**: V√©rification promoteur FNPI")
        # Extraction du nom du promoteur si mentionn√©
        import re
        promoteur_match = re.search(r'promoteur\s+([A-Za-z\s]+)', original_question, re.IGNORECASE)
        if promoteur_match:
            nom_promoteur = promoteur_match.group(1).strip()
            print(f"üîç V√©rification automatique du promoteur: {nom_promoteur}")
            resultat = verifier_promoteur_fnpi(nom_promoteur)
            print(resultat)
        else:
            print("üí° Pour v√©rifier un promoteur, pr√©cisez son nom")

# Version mise √† jour de chat_with_agent qui utilise la nouvelle fonction
async def chat_with_agent(agent, question: str, context):
    """Fonction helper pour discuter avec l'agent (version avec outils)"""
    return await chat_with_agent_and_tools(agent, question, context)

async def test_expert_guide_agent():
    """Test complet de l'Expert Guide Acqu√©reur"""
    
    print("üè† EXPERT GUIDE ACQU√âREUR - Test Complet")
    print("=" * 70)
    
    # Cr√©ation de l'agent
    print("üîß Cr√©ation de l'agent...")
    agent = create_guide_acquereur_agent()
    print(f"‚úÖ Agent cr√©√©: {agent.name}")
    print(f"   - Mod√®le: {agent.model}")
    print(f"   - Outils: {len(agent.tools)} outil(s)")
    
    # Cr√©ation du contexte
    print("\nüîß Cr√©ation du contexte d'invocation...")
    try:
        context = await create_invocation_context(agent)
        print("‚úÖ Contexte cr√©√© avec succ√®s")
    except Exception as e:
        print(f"‚ùå Impossible de cr√©er le contexte: {e}")
        return
    
    # Tests avec l'agent
    questions = [
        "Bonjour ! Je souhaite acheter un appartement au Maroc. Pouvez-vous m'expliquer les principales √©tapes ?",
        
        "Je gagne 15000 DH par mois avec 3000 DH de charges et j'ai 200000 DH d'apport. Quelle est ma capacit√© d'emprunt ?",
        
        "Quels sont les frais et taxes √† pr√©voir lors de l'achat d'un appartement de 800000 DH ?",
        
        "Donnez-moi la checklist pour la visite de livraison de mon futur logement.",
        
        "Comment puis-je v√©rifier qu'un promoteur est fiable et membre de la FNPI ?"
    ]
    
    print(f"\nüéØ Test avec {len(questions)} questions...")
    
    for i, question in enumerate(questions, 1):
        print(f"\n{'='*70}")
        print(f"üìã QUESTION {i}/{len(questions)}")
        print('='*70)
        
        response = await chat_with_agent(agent, question, context)
        
        if response:
            print(f"\n‚úÖ Question {i} trait√©e avec succ√®s")
        else:
            print(f"\n‚ö†Ô∏è Question {i} - Probl√®me de r√©ponse")
        
        # Pause entre les questions
        await asyncio.sleep(2)
    
    print(f"\n{'='*70}")
    print("üéâ TEST TERMIN√â")
    print("‚úÖ L'Expert Guide Acqu√©reur est op√©rationnel !")
    print('='*70)

# Fonction utilitaire pour les outils de calcul (peut √™tre utilis√©e s√©par√©ment)
def utiliser_outils_calcul():
    """D√©montre l'utilisation des outils de calcul s√©par√©ment"""
    
    print("\nüßÆ D√âMONSTRATION DES OUTILS DE CALCUL")
    print("=" * 50)
    
    # Test capacit√© d'emprunt
    print("\nüí∞ Test Capacit√© d'Emprunt:")
    resultat = calculer_capacite_emprunt(15000, 3000, 200000)
    print(resultat)
    
    # Test fiscalit√©
    print("\nüèõÔ∏è Test Calcul Fiscalit√©:")
    resultat = calculer_fiscalite(800000, "appartement", True)
    print(resultat)
    
    # Test checklist
    print("\nüìã Checklist Livraison:")
    resultat = checklist_visite_livraison()
    print(resultat)

# Fonction principale
async def main():
    """Fonction principale d'ex√©cution"""
    try:
        await test_expert_guide_agent()
        
        print("\n" + "="*70)
        print("üí° OUTILS DISPONIBLES S√âPAR√âMENT")
        print("="*70)
        utiliser_outils_calcul()
        
    except Exception as e:
        print(f"‚ùå Erreur g√©n√©rale: {e}")
        import traceback
        traceback.print_exc()

def run_expert_guide_test():
    """Lance le test de l'Expert Guide Acqu√©reur"""
    try:
        # Gestion de l'environnement asyncio
        try:
            loop = asyncio.get_event_loop()
            if loop.is_running():
                import nest_asyncio
                nest_asyncio.apply()
                task = loop.create_task(main())
                return task
            else:
                asyncio.run(main())
        except RuntimeError:
            asyncio.run(main())
    except Exception as e:
        print(f"‚ùå Erreur lors de l'ex√©cution: {e}")
        import traceback
        traceback.print_exc()

# Initialisation de l'agent pour usage externe
def get_agent():
    """Retourne l'agent configur√© pour usage externe"""
    return create_guide_acquereur_agent()

# Initialisation de l'agent global
root_agent = create_guide_acquereur_agent()

# # Point d'entr√©e principal
# if __name__ == "__main__":
#     print("üöÄ LANCEMENT DE L'EXPERT GUIDE ACQU√âREUR")
#     print("="*70)
#     run_expert_guide_test()
# else:
#     print("üì¶ Module Expert Guide Acqu√©reur import√©.")
#     print(f"‚úÖ Agent global 'root_agent' cr√©√©: {root_agent.name}")
#     print("üí° Utilisez run_expert_guide_test() pour lancer le test complet.")
#     print("üí° Ou utilisez directement 'root_agent' avec un contexte appropri√©.")